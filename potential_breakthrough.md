One: the data field of the epoll\_event struct is there for us to use, and we should use it to hold a pointer to some client-specific data, probably. Sadly, it isn't exposed through the Rust epoll crate very well (just as a u64), but maybe mio has something better?

More importantly: we don't need to hold a queue of messages, not really! If someone reads a partial message, we can still accept messages from others, but not send them yet! Simply have an array of booleans, one per client, that holds whether they've read a partial message. Also record if any of those are true in a global variable that gets updated whenever the array gets updated. (Really the array is more of a set of client ids, I think). If anyone's read a partial message, don't ever send anything. The message buffer for each client will fill up more frequently, but that's okay: it's the client's job to make sure they sent the message, and if their server-side message buffer fills up *and* the kernel's read buffer for that socket fills up, they'll have to wait to send, but they'll know that's happening. No VecDeque's required (at least, not for a queue of messages - maybe they're still a good idea for a ring buffer for each message).

Also, unregistering and re-registering fds with epoll is good and should be done, both for reading and writing, if there's ever a situation where you can't do anything on that event. This includes unregistering an fd for writing if you've finished sending to them, but also unregistering an fd for reading if you can't accept anymore. It makes things faster and wastes less power, since you aren't spinning in a tight loop for things you can't do anything with.
